{"meta":{"title":"ENvironmentSet","subtitle":"I LOVE JavaScript","description":"Jaewon's Computer Blog","author":"Jaewon Seo","url":"https://environmentset.github.io"},"pages":[],"posts":[{"title":"왜 리액트를 쓰나요?","slug":"Why-use-React","date":"2019-02-13T12:07:30.000Z","updated":"2019-02-13T12:07:30.932Z","comments":true,"path":"2019/02/13/Why-use-React/","link":"","permalink":"https://environmentset.github.io/2019/02/13/Why-use-React/","excerpt":"","text":"새로운 것을 배울 때에는 무엇을 배우든, 배우기 이전에 그 용도와 사용하는 이유에 대해서 알아야 합니다.용도를 모르면 알맞는 상황에서 사용할 수 없고, 사용하는 이유를 모르면 안 쓰느니만 못 하기 때문입니다. 리액트의 용도는 리액트의 공식 홈페이지에 아주 큰 글씨로 써져 있습니다. 네, 리액트는 UI(유저 인터페이스)를 만들기 위한 자바스크립트 라이브러리입니다. NOTE: 리액트를 라이브러리라 불러야 할 지, 프레임워크라 불러야 할 지에 대한 논쟁은 과거부터 이어져오는 꽤나 큰 떡밥입니다. 저는 제작사인 FB 측의 주장대로, 라이브러리라 부르도록 하겠습니다. 그렇다면, 리액트는 왜 쓰는걸까요?UI를 만들기 위한 라이브러리는 리액트만 존재하는 게 아닌 데 말이죠.여러 가지의 이유가 있겠지만, 이 글에서는 가장 대표적인 세 가지 이유를 알아보도록 하겠습니다. 강력한 추상화 도구, 컴포넌트리액트로 만들어진 어플리케이션은 기본적으로 엘리먼트(Element)라는 화면에 보여질 것을 표현하는 요소로 구성되어 있습니다.객체지향 프로그래밍 언어(OO Language)로 만들어진 프로그램이 객체로 구성되어 있는 것과 같이요. 엥, 그럼 컴포넌트는 뭐냐고요?너무 성급해 하지 마세요. 천천히 하자구요.객체지향 프로그래밍 언어에는 생성자가 있습니다. 객체를 생성하고 초기화하는 역할을 맡은 요소지요.마찬가지로, 리액트에는 리액트 엘리먼트를 생성하는 컴포넌트(Component)가 있습니다.컴포넌트는 props라는 입력을 받고, 리액트 엘리먼트를 만들어냅니다.즉, 어찌 되든 리액트 엘리먼트를 만들어 내기만 하면 되기 때문에 함수로도(함수 컴포넌트) 그리고 클래스(클래스 컴포넌트)로도 컴포넌트를 정의할 수 있습니다. NOTE: 사실 리액트 어플리케이션은 노드라는 엘리먼트의 상위 개념인 요소로 이루어져 있습니다. 컴포넌트 또한 노드를 결과로 생성하고요.하지만 노드가 무엇인지에 대해 정확하게 설명해드리려면 이후 소개해드릴 개념들까지 전부 끌어와야 하기 때문에, 지금은 엘리먼트라고 칭하도록 하겠습니다.여담으로, 실제로 모든 엘리먼트는 노드이기도 합니다. 좋아요, 이제 컴포넌트가 뭔지 감을 잡으셨을겁니다.그럼 지금부터는 컴포넌트가 왜 중요한 개념인지 알아보겠습니다. 먼저 결론부터 말씀드리자면, 컴포넌트는 복잡한 UI단을 추상화 해준다는 점에서 중요합니다.그렇다면, 도대체 왜 추상화를 해준다는 점이 중요할까요? 어려운 질문이지만 지금부터 그 이유를 알아가도록 하겠습니다.컴퓨터를 이용해 해결하는 문제들은 복잡한 문제들입니다.(만약 간단한 문제였다면 컴퓨터를 쓸 이유조차 없었겠죠.)그럼 복잡한 문제들을 어떻게 해결할까요?아시다시피, 컴퓨터로 문제를 해결하기 위한 방법을 제시하는 방법론을 프로그래밍 패러다임이라 부릅니다.즉, 프로그래밍 패러다임들은 앞에서 이야기한 복잡한 문제들을 해결하는 방법을 제시하고 있습니다.모든 프로그래밍 패러다임의 해답을 볼 수는 없으니 잘 알려진 프로그래밍 패러다임인 객체지향(Object-Oriented), 명령중심(혹은 절차지향, Imperative), 함수형(Functional)의 해답을 살펴보도록 하겠습니다.흥미롭게도, 같은 언어를 사용하여 작성한다고 하더라도 프로그램의 구조가 극과 극을 달릴 정도로 다르게 되는 이 세 패러다임이 복잡한 문제를 해결하는 방법의 기초적인 아이디어는 전부 같습니다.세 패러다임 모두 각자의 개념을 통해 문제를 작게 쪼개고, 해결한 뒤, 그 해결법을 다시 합쳐 복잡한 문제를 해결합니다. 프로그래밍 패러다임 문제를 쪼개기 위한 개념 객체지향 객체 명령중심 프로시저,서브루틴 함수형 함수 그럼 왜 프로그래밍 패러다임들은 왜 문제를 한번에 풀지 않고 쪼개서 풀까요?컴퓨터는 복잡한 문제를 한번에 해결할 수 없는 걸까요?제가 좋아하는 프로그래머인 Bartosz Milewski의 글에 따르면, 아닙니다.프로그래밍 패러다임들이 복잡한 문제를 쪼개서 푸는 아이디어에 기반한 이유는 사람의 뇌의 한계 때문입니다.아무리 컴퓨터가 복잡한 문제를 한번에 해결할 수 있다고 하여도, 그 컴퓨터에게 명령을 내리는(컴퓨터는 명령에 따라 일을 할 뿐, 스스로 무언가를 하지 않습니다.) 사람이 그런 방법을 설계해 낼 수 없으면 컴퓨터는 무용지물이 되어버립니다.그리고 앞에서도 말씀드렸듯이, 사람은 복잡한 문제를 한번에 해결해 내는 방법을 설계할 수 없습니다.그럼 컴퓨터는 쓸모없는 물건인걸까요? 우리는 지금까지 의미없는 일을 한 걸까요? 지금까지 만들어 온 프로그램들은 컴퓨터가 필요없을 정도로 쉬운 문제들을 해결하는 프로그램들이였던걸까요?전혀 아닙니다.분명 우리는 지금까지 복잡한 문제를 해결하는 방법을 설계해 왔습니다.어떻게 한 걸까요? 초능력이라도 발휘된걸까요?아쉽게도, 초능력은 아니지만 초능력에 비견될 만한 인간의 능력을 통해 설계해온 것입니다.어떤 능력이냐고요? 바로 상상력 입니다.프로그래밍 패러다임들은 문제를 각자의 개념을 통해 쪼갠다고 하였습니다.왜 굳이 각자의 개념을 통해 쪼갤까요? 그냥 쪼개면 안 되는걸까요?프로그래밍 패러다임들이 문제를 쪼개기 위한 자신만의 개념을 가진 이유는 간단합니다, 쪼개어 해결한 문제를 푸는 법을 숨기기 위해서입니다.왜 기껏 해결책을 찾아놓고 다시 숨길까요?간단합니다, 프로그래머가 신경쓰지 않게 하기 위해서입니다.앞서 이야기했듯이, 사람의 뇌의 정보 저장 능력 및 처리 능력은 한계가 있습니다.아무리 문제를 쪼개었다고 하여도, 쪼개진 문제의 해결책을 다른 쪼개진 문제들의 해결책과 합치기 위해서는 필히 뇌에 해결책을 저장해야 합니다.이렇게 저장하다 보면 사람의 뇌는 한계에 도달하게 되어 있지요.하지만, 그 해결책을 숨긴다면 어떨까요?프로그래머는 그저 어떤 상자 안에 해결책이 들어 있다고 상상하기만 하면 되는겁니다. 안에 문제를 넣으면 그 문제에 대한 답을 다시 던져주는 상자요!이렇게 문제를 추상화시키면 이론상 모든 문제를 뇌에 저장할 수 있게 됩니다.즉, 해결책을 무한대로 합쳐나갈 수 있다는 이야기입니다!다시 처음으로 돌아가 결론을 내리자면, 추상화는 사람의 뇌로는 설계할 수 없는 복잡한 문제에 대한 해결책을 설계할 수 있게 해 주기 때문에 중요합니다. 다시말해, 리액트의 컴포넌트는 프로그래밍 패러다임의 복잡한 문제를 쪼개기 위한 개념 같은 존재로, 복잡하고 거대한 UI도 쉽게 설계할 수 있게 해 주기 때문에 중요합니다. 옵져버블 없는 리액티브 프로그래밍UI는 사용자와 끊임없이 상호작용합니다.사용자의 입력에 따라 어플리케이션의 상태가 변화하고, 변화된 상태에 따라 화면이 변화합니다.상태와 화면, 이 둘은 변화하는 값(Value over time)입니다. 변화하는 값들은 다루기 어렵습니다.값의 변화에 맞추에 관련된 다른 것들도 변화시키기 위해 항상 예의주시해야 하기 때문입니다.하지만 사람들은 여기서 포기하지 않고, “값의 변화를 스스로 전파시키게 하면 된다.” 라는 아이디어에 기반해 리액티브 프로그래밍이라는 프로그래밍 패러다임을 고안해 냈습니다.리액티브 프로그래밍(Reactive Programming)은 옵져버블(Observable)과 여러 개념들을 사용해 변화하는 값들을 훌륭히 다룹니다.하나의 예시를 보여드리자면, 이렇게요. NOTE: 옵져버블, 스트림(Stream). 이 두 용어는 동의어입니다. 리액티브 프로그래밍 커뮤니티는 어떤 단어를 쓰든 같은 의미라고 보지요. 12345678import &#123; fromEvent &#125; from 'rxjs';import &#123; map &#125; from 'rxjs/operators';const inputElement = document.getElementById('textInput');const input$ = fromEvent(inputElement, 'change'); // inputElement에서 'change' 이벤트가 발생할 때 마다 그 이벤트를 자신의 구독자(subscriber)에게 전달하는 옵져버블을 만듭니다.const text$ = input$.pipe(map(event =&gt; event.target.value)); // input$가 값을 전달할 때 마다 주어진 함수를 이용해 그 값을 변형시킨 후 다시 전달하는 옵져버블을 만듭니다.text$.subscribe(console.log); // text$ 옵져버블이 전달한 값을 출력합니다. 짜잔, 리액티브 프로그래밍을 하면 이렇게 데이터 플로우를 선언하여 비동기, 동기 할 것 없이 변화하는 값들을 쉽게 다룰 수 있습니다.듣기에는 정말 좋아 보이지만, 리액티브 프로그래밍에도 몇몇 문제가 있습니다.가장 큰 문제는, 프로그래머가 옵져버블 간의 구독(subscription)에 많이 신경써야 합니다.시그널(singal) 옵져버블이 아닌 이벤트(event) 옵져버블 들은 구독 되는 시점이 중요하기 때문입니다.이는 옵져버블과 그 주위 환경을 프로그래머가 다룸으로서 생기는 문제로, 리액트는 옵져버블을 감춤으로서 이 문제를 해결했습니다.즉, 간단하게 표현하면 리액트는 다음과 같이 구성된 것 입니다. 12345import React from 'react';function MyComponent() &#123;&#125; // 여기에 멋진 컴포넌트가 있다고 가정하세요.props$.map(MyComponent) // props 들의 옵져버블이 props를 전달할 때 마다 그 props를 가지고 컴포넌트를 호출합니다. 결과적으로 props들의 옵져버블을 엘리먼트들의 옵져버블로 만듭니다. NOTE: 지금까지 소개해드린 리액트의 기능이 매우 적어, 예시로 보여드리기에는 조금 부족한 감이 있는 props로 보여드리게 되었습니다.그렇기에 리액트를 처음 접하신다면 이해하시기 조금 어려우실겁니다. 그러니 너무 이해하려 하지 마시고, 어느 정도 배우신 후에 다시 돌아와서 이 문단을 살펴보세요.만약 state를 아신다면 이 문장이 더 도움이 될 겁니다. “컴포넌트의 state가 변경되면 리액트는 그 컴포넌트의 메서드를 호출함으로서 다시 랜더링을 요청합니다. 네, 리액트는 거대한 옵져버블이고 우리의 컴포넌트는 그 옵져버블을 구독하는 옵져버(Observer) 일 뿐입니다. 리액티브 프로그래밍의 옵져버블이나 GoF의 옵져버 패턴에서 인터페이스만 바뀐 것이지요.” 또 다른 문제는 학습 비용(Learning curve)입니다.옵져버블, 오퍼레이터, 구독, 스트림 등 많은 개념으로 이루어져 있고, 이 개념들을 정확하게 알지 못하면 코드가 돌아가지조차 않는 상황이 발생하기 때문에 리액티브 프로그래밍의 학습 비용은 상당하다고 할 수 있습니다(적어도 다른 프로그래밍 패러다임은 돌아가기는 돌아갑니다. 구조가 이상하게 뽑혀 나오거나 효과를 발휘하지 못하는 상황에 빠지게 되어서 문제지만요.).하지만 리액트는 저 모든 걸 리액트 안으로 숨겨 버림으로서 사용자가 리액티브 프로그래밍에 대해 무지하여도 문제가 없도록 하였습니다. 정리하자면, 리액트는 리액티브 프로그래밍을 함으로서 얻을 수 있는 이득을 거의 공짜로 제공해 줍니다.어떤 이득이냐고요? 변화하는 값을 선언적인 방법으로 손쉽게 다루는 것이요! 결과적으로 여러분은 사용자와 상호작용하는 UI(Interactive UI)를 정말 간단하게 만들 수 있는 것입니다! 가상 돔을 통한 빠른 랜더링자, 마지막은 아마 여러분들이 잘 아실만한 이야기입니다.네, 바로 가상 돔(Virtual DOM, VDOM)입니다. 아까 제가 컴포넌트에 대한 이야기를 해드릴 때, 이런 말을 했었지요. 리액트로 만들어진 어플리케이션은 기본적으로 엘리먼트(Element)라는 화면에 보여질 것을 표현하는 요소로 구성되어 있습니다. 무언가 비슷한 것이 떠오르지 않으시나요?네, 바로 문서 객체 모델(Document Object Model, DOM) 입니다.DOM은 현재 문서를 DOM 노드(Node)들의 트리(Tree)로 표현하지요. 왜 리액트는 DOM 노드를 사용하지 않고, 자체적인 엘리먼트들을 통해 화면을 구성할까요?사실, 리액트는 DOM을 내부적으로 사용합니다. 그러나 우리에게는 노출시켜주지 않는 것일 뿐 입니다.왜냐하면 DOM은 변경에 민감하고, 어플리케이션의 성능에 큰 영향을 주기 때문에 직접 다루는 일은 위험하기 때문이죠.그걸 알고 있는 리액트는 엘리먼트로 논리적인, 가상의 DOM 트리를 프로그래머가 다루게 하고 자신은 프로그래머가 만들어낸 가상의 DOM 트리를 분석하여 DOM 트리를 정교하고 똑똑하게(필요한 부분만 업데이트 하거나, 당장 필요하지 않은 업데이트는 미루고, 변경 작업을 스케쥴링 하는 등 여러 최적화를 합니다) 다루지요. 즉, 리액트는 개발자가 신경쓰기 힘든 사소한 부분들을 직접 해결해주어 개발자가 어플리케이션 개발에 집중할 수 있게 해줍니다. 개발자들은 데이터를 다루고 화면을 구성하기 위해 고용되었지, DOM 트리랑 최적화 싸움 하라고 고용된 건 아니니까요(고용주 입장에서요, 최적화도 물론 중요하지만 프로덕트가 만들어지는 게 더 중요하지요.). 자, 지금까지 리액트를 사용하는 이유들에 대해 알아보았습니다.이 외에도 몇몇 이유가 더 있지만 이 정도로도 충분히 동기를 부여해드렸다고 생각하기 때문에 굳이 다루지 않도록 하겠습니다. 그럼 저는 다음 글인 새로운 문법을 소개합니다! 로 다시 찾아뵙도록 하겠습니다.좋은 하루 되세요 :)))","categories":[{"name":"JavaScript","slug":"Documents-About-JavaScript","permalink":"https://environmentset.github.io/categories/Documents-About-JavaScript/"},{"name":"Learn you a React for good","slug":"Documents-About-JavaScript/Learn-you-a-React-for-good","permalink":"https://environmentset.github.io/categories/Documents-About-JavaScript/Learn-you-a-React-for-good/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://environmentset.github.io/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"https://environmentset.github.io/tags/React/"}]},{"title":"Learn you a React for good - preface","slug":"Learn-you-a-React-for-good-preface","date":"2019-02-12T10:11:32.000Z","updated":"2019-02-13T01:01:45.203Z","comments":true,"path":"2019/02/12/Learn-you-a-React-for-good-preface/","link":"","permalink":"https://environmentset.github.io/2019/02/12/Learn-you-a-React-for-good-preface/","excerpt":"","text":"Learn you a React for good 은 React 튜토리얼 시리즈입니다.제가 이 글을 작성하고 있는 시점의 최신 버전인 16.8.1 버전을 기준으로 글을 작성할 예정입니다. 목차 제목 주제 왜 리액트를 쓰나요? 리액트를 쓰는 이유 새로운 문법을 소개합니다! JSX 컴포넌트 길들이기 컴포넌트 세기의 빅매치: 상속 vs 합성 Mixin, HOC(High-Order-Component) 너만을 위한 특별한 이벤트 SyntheticEvent 우리 사이에 굳이 말 해야 알아? Content 난 너만 바라볼거야 Ref, forwarding Ref 하늘이 무너져도 솟아날 구멍이 있는데 리액트에도 구멍 하나 없을리가요 Portal Hook, Hook, 이건 입에서 나는 소리가 아니여! Hook 우리 이제 따로 살자 Code Splitting 법대로 하자! Strict Mode 땅땅, 당사자들 간의 조정이 있겠습니다 Reconciliation 여담이지만, 튜토리얼 시리즈의 이름은 learn you a Haskell for good 의 패러디입니다.","categories":[{"name":"JavaScript","slug":"Documents-About-JavaScript","permalink":"https://environmentset.github.io/categories/Documents-About-JavaScript/"},{"name":"Learn you a React for good","slug":"Documents-About-JavaScript/Learn-you-a-React-for-good","permalink":"https://environmentset.github.io/categories/Documents-About-JavaScript/Learn-you-a-React-for-good/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://environmentset.github.io/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"https://environmentset.github.io/tags/React/"}]},{"title":"You don't know everything of arguments object","slug":"You-don-t-know-Arguments-Object","date":"2019-01-31T14:20:13.000Z","updated":"2019-02-11T06:44:14.937Z","comments":true,"path":"2019/01/31/You-don-t-know-Arguments-Object/","link":"","permalink":"https://environmentset.github.io/2019/01/31/You-don-t-know-Arguments-Object/","excerpt":"","text":"이번 글에서는 우리 모두가 알고 있는 arguments 객체에 대한 깊고도 깊은 이야기를 다룹니다. 본격적으로 글을 시작하기 전에, 잠시 arguments 객체와 관련된 자바스크립트 퀴즈를 풀어보도록 하지요. 123456function problem1(a, b, c) &#123; arguments[0] = 100; return [a, b, c];&#125;problem1(1, 2, 3) // 반환값을 맞추어 보세요! 정답: [100, 2, 3] 12345function problem2(a, b, c) &#123; return Object.hasOwnProperty(arguments, 0);&#125;problem2(1, 2, 3) // 반환값을 맞추어 보세요! 정답: false 123456function problem3(a, b, c = 10) &#123; arguments[0] = 100; return [a, b, c];&#125;problem3(1, 2) // 반환값을 맞추어 보세요! 정답: [1, 2, 10] 12345function problem4(a, b, c = 10) &#123; return arguments.callee;&#125;problem4(1, 2) // 반환값을 맞추어 보세요! 정답: 반환값 없음(TypeError) 123456function problem5() &#123; arguments[2] = 3; return Array.prototype.slice.call(arguments);&#125;problem5(1, 2); // 반환값을 맞추어 보세요! 정답: [1, 2] 자, 몇 개나 맞추셨나요?위 퀴즈를 전부 맞추셨다면, 이 글은 안 읽으셔도 됩니다. 저 문제들의 답이 나오는 이유와, 그 비하인드 스토리를 다루는 게 이 글의 주제이기 때문이죠!또한 실무에서 사용할 법한 지식을 원하신다면, 이 글을 안 읽으셔도 됩니다. 왜냐면 제가 할 이야기들은 실무와 많이 동떨어진 이야기이거든요!그렇담, 지금까지 뒤로가기를 안 누르신 여러분들께 지금부터 arguments의 속사정을 들려드리도록 하겠습니다! What we already knows먼저, 우리가 알고 있는 기본적인 상식들을 살펴보고 넘어가겠습니다. arguments 객체는 함수의 전달인자(arguments)를 담고 있는 객체입니다. arguments 객체는 ArrayLike(정수가 key로서 사용되는 객체, 배열과 같이 데이터 간의 순서가 있는 객체)입니다. 전달인자는 왼쪽부터 인덱스를 부여받습니다(0.. 1.. 2..). 그러므로 우리는 다음과 같은 방법을 통해 함수에게 전달된 값들을 읽을 수 있습니다: 12345function example1(a) &#123; return arguments[0] === a;&#125;example1(1) // true 또한 arguments 객체에 담기는 값들은 전달인자이기 때문에 매개변수의 정의 여부에 상관하지 않고 읽을 수 있습니다! 12345function example2() &#123; return arguments[0];&#125;example2(1) // 1 와우! 멋진 객체이군요! Birth of arguments object세상 모든 게 그렇듯, arguments 객체도 필요에 의해 만들어진 개념입니다.도대체 어떤 이유로 이런 객체를 만들었는지 알아보도록 하지요. Rest parameter우리가 잘 알고 있는 Rest parameter 문법은 ES6(2015)에서 추가된 문법입니다.여기서 여러분들은 자바스크립트의 최초 버전이 1997년에 나왔다는 걸 잊지 마셔야 합니다.도대체 그 18년동안 자바스크립트 개발자들은 어떻게 살았었을까요? 나머지 매개변수를 구현했었을까요? 정답은.. 진짜로 그 18년동안 사람들은 arguments 객체를 사용해서 나머지 매개변수를 구현해서 사용했었습니다. 바로 이렇게요:출처: Partial Application in JavaScript - John resig12345Function.prototype.curry = function() &#123; var fn = this, args = Array.prototype.slice.call(arguments); return function() &#123; return fn.apply(this, args.concat(Array.prototype.slice.call(arguments))); &#125;; 앞서 살펴보았듯, arguments 객체는 매개변수의 정의 여부에 상관하지 않기 때문에 이렇게 넘쳐버린 전달인자들도 담습니다.그래서 저렇게 몇 개든 인자를 받아서 처리할 수 있는 것이지요. Make anonymous function Recursive!arguments 객체에는 callee라는 특별한 프로퍼티가 하나 있습니다.이 프로퍼티에는 현재 실행중인 함수가 담겨 있는데요, 굳이 함수의 이름을 쓰지 않고 왜 이 프로퍼티를 사용했었을까요? 그 이유는 시간을 거슬러 내려가, 자바스크립트의 초창기 버전(ES1~ES2)에서 찾을 수 있습니다. ES3 이전에는, 자바스크립트에 함수 표현식이 존재하지 않았었습니다.그래서 함수를 만들기 위해 프로그래머들은 함수 선언 혹은 Function 생성자를 사용했었습니다. 123function myFunction() &#123;&#125; // 함수 선언// orvar myFunction2 = new Function(); // Function 생성자 이 중, Function 생성자로 만들어진 함수는 익명 함수입니다. 생성된 함수의 이름이 &#39;anonymous&#39; 이기 때문이죠. (여담이지만, 자바스크립트의 익명 함수는 함수명(function.name) 이 &#39;anonymous&#39; 인 함수와 &#39;&#39; 인 함수, 두 가지가 있습니다.이 이야기는 다음 포스트에서 다루도록 하겠습니다.) 자, 여기서 퀴즈 하나 나갑니다. 익명 함수는 어떻게 재귀 호출을 할 수 있을까요? 1234function myFunction1(a) &#123; return a ? a : a + myFunction1(a - 1);&#125;var myFunction2 = new Function('return a ? a : a + /**여기에 뭐가 들어가야 할까요?**/(a - 1);', 'a'); 당연하게도 자신을 가르키는 이름이 없기 때문에 식별자를 통한 직접적인 참조가 불가능합니다. 이러한 문제를 해결하기 위해 자바스크립트는 arguments.callee 프로퍼티를 추가했습니다. 1var myFunction2 = new Function('return a ? a : a + arguments.callee(a - 1);', 'a'); 하지만 다들 아시다시피, ES3에서 함수 표현식이 추가된 이후, Function 생성자의 사용 빈도가 급격히 줄었습니다.그리고 함수 표현식은 선택적으로 식별자를 지정할 수 있게 해 주지요.그래서 지금은 더 이상 안 쓰이는 테크닉입니다. 정말 희귀한 케이스가 아닌 이상 안 씁니다. Seeing internal of arguments object자, 지금부터 본격적으로 arguments 객체의 내부를 열어보도록 하겠습니다. 가장 먼저 arguments 객체가 생성되는 부분을 보도록 하겠습니다. NOTICE: 이 글에서는 ECMA-262, 9th edition 을 해설 목적으로 사용하고 있습니다. 엇, arguments 객체를 생성하는 Abstract operation 이 두개네요?네, 보시다시피 arguments 객체는 내부적으로 두 가지 종류가 있습니다.하나는 Mapped Arguments 객체구요, 하나는 Unmapped Arguments 객체입니다. Unmapped Arguments 객체는 함수가 strict mode 이거나, 함수의 파라매터 정의에 ES6의 feature(기본 매개변수, 디스트럭쳐링 바인딩 패턴, 나머지 매개변수)가 사용된 경우에 만들어지고,그렇지 않은 경우에는 Mapped Arguments 객체가 만들어집니다. 두 객체의 차이를 한번 알아본 뒤, 명세를 이어서 읽어보도록 하겠습니다. Feature Mapped Arguments Object Unmapped Arguments Object 2-way data binding yes no kind of object exotic ordinary uses [[ParameterMap]] yes no throw error when someone tried to access ‘callee’ property no yes 자, 먼저 가장 간단한 Unmapped Arguments 객체를 생성하는 CreateUnmappedArgumentsObject 를 읽어보도록 하지요. 여기서 argumentList는 전달인자들의 배열이라고 생각하셔도 무방합니다.(ex: f(1, 2) 라면 argumentList는 [1, 2]) 1. len 이라는 변수를 만들고, argumentList의 길이로 초기화합니다. 2. Object.prototype을 프로토타입으로 갖는 객체를 만들고, [[ParameterMap]] 이라는 내부 프로퍼티를 추가합니다. 그 후 만들어진 객체를 obj라는 변수에 넣습니다. 이 객체는 차후 Unmapped Arguments 객체가 됩니다. 3. obj.[[ParameterMap]]을 undefined로 초기화합니다. (왜냐면 Unmapped Arguments 객체니까요!) 4. obj 에 값이 len이고 키가 length인 프로퍼티를 정의합니다. 5~6. obj에 argumentList에 있는 각 argument을 값으로, 각 인덱스를 키로 하는 프로퍼티들을 정의합니다. 7. obj에 Symbol.iterator을 키로, Array.prototype.values를 값으로 하는 프로퍼티를 정의합니다. 8. obj에 callee라는 accessor 프로퍼티를 정의합니다. Getter와 Setter 모두 호출 즉시 TypeError를 throw 하는 함수를 넣었습니다. 9. 완성된 Unmapped Arguments 객체를 반환합니다. 이게 Unmapped Arguments 객체의 전부입니다! 간단하지요?이제 본격적으로, 좀 더 어려운 녀석을 살펴보도록 하겠습니다.바로 Mapped Arguments 객체지요. 여기서 func는 호출된 함수 객체, formals는 함수의 매개변수가 있는 코드 조각(소스 코드), argumentsList는 매개변수들의 리스트(배열), env는 여러분들이 잘 아시는 Environment Record 입니다. 2. len 이라는 변수를 만들고, argumentList의 길이로 초기화합니다. 3. obj 라는 변수에 [[ParameterMap]] 이라는 내부 프로퍼티를 가지는 빈 객체를 넣습니다. 4~9. obj 객체에 객체의 기본적인 동작(프로퍼티 접근, 변경, 삭제 등등등)을 정의하는 메서드들을 주입합니다. 10. obj의 프로토타입을 Object.prototype으로 설정합니다. 11. obj를 확장할 수 있는 객체로 만듭니다. 12. map 이라는 변수를 만들고 빈 객체로 초기화합니다. 13. obj.[[ParameterMap]] 을 map으로 설정합니다. 14. parameterNames 라는 변수를 만들고, formals에 있는 매개변수 식별자들의 리스트로 초기화합니다. 15~17. obj에 argumentList에 있는 각 argument을 값으로, 각 인덱스를 키로 하는 프로퍼티들을 정의합니다. 18. obj 에 값이 len이고 키가 length인 프로퍼티를 정의합니다. 19~21. obj와 호출된 함수의 스코프간의 양방향 데이터 바인딩을 구현하기 위한 코드들입니다. (이 부분은 잠시 후에 다시 살펴보겠습니다.) 22. obj에 Symbol.iterator을 키로, Array.prototype.values를 값으로 하는 프로퍼티를 정의합니다. 23. obj에 &#39;callee&#39;을 키로, 호출된 함수를 값으로 하는 프로퍼티를 정의합니다. 24. 완성된 Mapped Arguments 객체를 반환합니다. 자, 여기까지는 Mapped Arguments 객체가 생성되는 과정이였습니다.그럼 이제 어떻게 양방향 바인딩이 구현되었는지 살펴보도록 하지요. 19. mappedNames 라는 변수를 만들고 빈 리스트로 초기화합니다. 20. index 라는 변수를 만들고, numberOfParameters - 1 한 값을 넣습니다. &lt;– numberOfParameters의 값은 parameterNames의 길이입니다. 21. index 가 0보다 작아질때까지 아래의 단계를 반복합니다. a. name 이라는 변수를 만들고, 그 값을 parameterNames[index](parameterNames 가 리스트이므로 index 번째 요소를 가져오는 것 입니다.) 로 합니다. b. 만약 name 이 mappedNames에 포함되있지 않다면, i. name을 mappedNames의 가장 마지막 요소로서 추가합니다(push). ii. 만약 index &lt; len 이라면, 1. g라는 변수를 만들고, MakeArgGetter(name, env)의 결과값으로 초기화합니다. (MakeArgGetter는 이따 살펴보겠습니다.) 2. p라는 변수를 만들고, MakeArgSetter(name, env)의 결과값으로 초기화합니다. (MakeArgSetter도 이따 살펴보겠습니다.) 3. map에 String(index)를 키로 하고, g를 Getter로, p를 Setter로 하는 접근자 프로퍼티를 정의합니다. c. index의 값을 1 줄입니다. 처음에 CreateMappedArgumentsObject를 설명해드릴 때 생략한 부분인데요.이 부분에서는 arguments 객체의 프로퍼티와, 호출된 함수의 스코프를 이어주는 접근자를 생성해주는 MakeArgGetter와 MakeArgSetter을 이용해각 매개변수와 arguments에 들어있는 전달인자의 값을 연결시켜주고 있습니다. 자, 그럼 이제 MakeArgGetter와 MakeArgSetter가 어떻게 둘을 이어주는 지 알아보도록 하겠습니다. name은 아시다시피 매개변수의 이름이구요, env는 Running Execution Context의 Lexical Environment의 Environment Record 입니다.(쉽게말해 현재 실행중인 코드의 스코프라는 이야기입니다.) 1. steps 라는 변수를 만들고 아래에 있는 ArgGetter 함수로 초기화합니다. 2. getter 이라는 변수를 만들고, CreateBuiltinFunction(steps, &lt;&lt; [[Name]], [[Env]] &gt;&gt;) 의 결과값으로 초기화합니다. ArgGetter 을 호출할 수 있는 자바스크립트의 함수로 만들고, 내부 프로퍼티인 [[Name]] 과 [[Env]]를 정의하는 겁니다.) 3. getter.[[Name]]의 값을 name으로 설정합니다. 4. getter.[[Env]]의 값을 env로 설정합니다. 5. getter를 반환합니다. 아쉽게도 MakeArgGetter에는 직접적으로 둘을 이어주는 로직은 없습니다. 그건 ArgGetter의 역할이거든요.자, 이제 ArgGetter을 보도록 하겠습니다.(ArgGetter에서 f는 호출된 ArgGetter를 의미합니다. arguments.callee와 같게 보셔도 무방합니다.!) 1. name이라는 변수를 선언하고, 그 f.[[Name]]으로 초기화합니다. 2. env이라는 변수를 선언하고, 그 f.[[Env]]으로 초기화합니다. 3. env.GetBindingValue(name, false)의 결과값을 반환합니다.(아까 받은 스코프에서 name과 묶인 값을 찾는 부분입니다.) 그리 어렵지는 않지요? 그럼 이제 MakeArgSetter를 보도록 하겠습니다. 여기서도 name은 매개변수의 이름이구요, env는 Running Execution Context의 Lexical Environment의 Environment Record 입니다. 1. steps 라는 변수를 만들고 아래에 있는 ArgSetter 함수로 초기화합니다. 2. setter 이라는 변수를 만들고, CreateBuiltinFunction(steps, &lt;&lt; [[Name]], [[Env]] &gt;&gt;) 의 결과값으로 초기화합니다. ArgSetter 을 호출할 수 있는 자바스크립트의 함수로 만들고, 내부 프로퍼티인 [[Name]] 과 [[Env]]를 정의하는 겁니다.) 3. setter.[[Name]]의 값을 name으로 설정합니다. 4. setter.[[Env]]의 값을 env로 설정합니다. 5. setter를 반환합니다. MakeArgSetter에도 직접적으로 arguments 객체의 프로퍼티와 함수의 스코프에 있는 변수를 이어주는 로직은 없습니다.그건 ArgSetter의 역할이기 때문이죠.자, 이제 ArgSetter을 보도록 하겠습니다.(여기서도 f는 호출된 ArgSetter입니다., value는 다들 아시는 setter의 매개변수(새로 set 될 값)입니다.) 1. name이라는 변수를 선언하고, 그 f.[[Name]]으로 초기화합니다. 2. env이라는 변수를 선언하고, 그 f.[[Env]]으로 초기화합니다. 3. env.SetMutableBinding(name, value, false)의 결과값을 반환합니다.(아까 받은 스코프에서 name과 묶인 값을 변경하는 부분입니다.) 자, 이렇게 우리는 기초적인 부분들을 살펴 보았습니다.하지만 아직 여러분들이 보지 않은 부분이 있습니다. 바로 위에서 우리가 양방향 바인딩을 위해 만들고 arguments에 붙인 접근자들이 호출되는 부분들이죠.지금부터는 그 부분들을 찾아서 보도록 하겠습니다. 그 전에, 기반 지식에 대한 간단한 설명을 먼저 하도록 하겠습니다.자바스크립트의 객체들의 시멘틱은 internal method라는 것에 의해 정의됩니다.어떤 객체에 대한 동작/연산들이 internal method 라는 것을 통해 정의된다는 이야기인데요.다만, 불규칙하게 정의되면 구현체 뿐만 아니라 명세에서도 각 객체를 위한 로직을 따로 작성해야 하므로 그 불편함을 없에기 위해 자바스크립트 명세에서는 기본적인 동작들을 위한 인터페이스를 정의하고, 최소한의 조건을 명시하고 있습니다.또한, 자바스크립트 명세에서는 특별한 internal method가 필요하지 않은 객체들을 위해 앞서 언급한 최소한의 조건을 충족하는(또한 default behavior인) internal method들을 제공하고 있습니다.만약, 한 객체의 기본적인 동작들을 구현하고 있는 internal method들이 전부 default behavior인 internal method라면, 그 객체를 ordinary 객체라고 부릅니다.그렇지 않다면 Exotic 객체라고 부르지요. 위의 arguments 객체의 경우도 Unmapped arguments 객체는 ordinary 객체, Mapped arguments 객체는 Exotic 객체입니다. Mapped arguments 객체는 Exotic 객체다. 감이 오지 않으시나요?Mapped arguments 객체는 객체의 몇몇(Get/Set/Delete …etc) 연산이 default behavior가 아닌, 다른 말로 특별한 로직이 있는 객체입니다. 자, 그럼 지금부터 위에서 살펴본 접근자들을 호출하는 로직이 들어있는, arguments 객체의 프로퍼티 접근/수정 연산을 다루는 [[Get]] internal method와 [[Set]] internal method를 살펴보도록 하겠습니다. 여기서 P는 접근할 프로퍼티 키, Receiver는 접근할 프로퍼티가 접근자 프로퍼티라면, 적절한 접근자를 호출하게 되는데 이 때 접근자의 this 값으로서 사용되는 값 입니다. 1. args 라는 변수를 선언하고, 이 internal method가 담겨있는 arguments 객체로 초기화합니다. 2. map 이라는 변수를 선언하고, args.[[ParameterMap]] 으로 초기화합니다. 3. isMapped 라는 변수를 선언하고, ! HasOwnProperty(map, P) 의 결과로 초기화합니다. (자바스크립트 코드로 표현하자면 map.hasOwnProperty(P)와 같은 로직입니다.) 4~5. 만약 isMapped가 false라면 arg(arguments)객체에서 프로퍼티를 찾고 그 결과를 반환합니다. 6. 그렇지 않은 경우, map 객체에서 프로퍼티를 찾고 그 결과를 반환합니다.(프로퍼티를 찾을 때, 찾은 프로퍼티가 접근자 프로퍼티이면, 그 프로퍼티의 Get 접근자를 실행시킵니다. 이 부분이 바로 우리의 ArgsGetter 접근자가 호출되는 부분입니다.) 짠, 거이 다 왔습니다. 힘내세요!지금부터 볼 녀석은 [[Set]] internal method 입니다. 여기서도 P는 접근할 프로퍼티 키, Receiver도 접근할 프로퍼티가 접근자 프로퍼티라면, 적절한 접근자를 호출하게 되는데 이 때 접근자의 this 값으로서 사용되는 값 입니다.그리고.. V는 새로 설정중인 값 입니다. NOTICE: isMapped 변수의 스코프가 이상해 보이신다면, 정상이십니다. 저도 방금 알았네요. 이슈로 올려야겠어요. 1. args 라는 변수를 선언하고, 이 internal method가 담겨있는 arguments 객체로 초기화합니다. 2 &amp; 5. SameValue(args, Receiver) 가 false 라면 args 객체에 키가 P이고 값이 V인 프로퍼티를 설정하고 그 결과를 반환합니다. 3 &amp; 4. args.[[ParameterMap]] 객체에 P를 키로 갖는 프로퍼티가 있으면 그 프로퍼티에 V를 설정합니다(여기서 ArgSetter가 호출됩니다!) 5. args 객체에 키가 P이고 값이 V인 프로퍼티를 설정하고 그 결과를 반환합니다. Time to explain!자, 지금까지 우리는 arguments 객체의 종류, arguments 객체가 어떻게 생성되는 과정, 어떻게 양방향 데이터 바인딩을 구현했는지를 보았습니다.이 정도면 여러분들 스스로를 arguments 학사 라고 칭하셔도 됩니다.(이 글에서 다루지 않은 디테일하지만 크게 중요하지는 않은 사항들이 남았거든요..ㅜㅜ) 자, 이제 마지막으로, 글의 서문에서 여러분들이 풀은 문제에 대한 해설을 지금까지 배운 지식들을 기반으로 해설해드리도록 하겠습니다. 1번 문제: Mapped arguments 객체는 자신의 프로퍼티의 변경사항을 매개변수에 반영시킵니다.123456function problem1(a, b, c) &#123; arguments[0] = 100; return [a, b, c];&#125;problem1(1, 2, 3) // 반환값을 맞추어 보세요! 정답: [100, 2, 3] 간단한 문제입니다. problem1 에서의 arguments 객체는 Mapped Arguments 객체이기 때문에, arguments[0]과 a 사이의 바인딩이 생기게 됩니다.그래서 arguments[0]을 수정했을 때, 그 변경사항이 a에도 반영된 것이지요. 2번 문제: [[ParameterMap]]가 공유한 프로퍼티는 arguments 객체의 own 프로퍼티가 아닙니다.12345function problem2(a, b, c) &#123; return Object.hasOwnProperty(arguments, 0);&#125;problem2(1, 2, 3) // 반환값을 맞추어 보세요! 정답: false arguments 객체를 통해 arguments.[[ParameterMap]] 에 있는 프로퍼티를 접근할 수 있음에도 불구하고, 접근할 수 있는 프로퍼티들이 arguments 객체에 정의되있는 프로퍼티는 아니기에 false가 나옵니다.여담으로, 프로토타입 객체의 프로퍼티가 공유되는 방식은 arguments.[[ParameterMap]]의 프로퍼티가 공유되는 방식과 같은 방식입니다. 3번 문제: Unmapped arguments 객체는 자신의 프로퍼티의 변경사항을 매개변수에 반영시키지 않습니다.123456function problem3(a, b, c = 10) &#123; arguments[0] = 100; return [a, b, c];&#125;problem3(1, 2) // 반환값을 맞추어 보세요! 정답: [1, 2, 10] problem3의 매개변수 중, c가 기본값 문법을 사용하고 있기 때문에 Mapped arguments 객체가 아닌 Unmapped arguments 객체가 생성됩니다.그리고.. 아시다시피 Unmapped arguments 객체는 양방향 바인딩을 구현하고 있지 않지요. 그래서 arguments 객체의 프로퍼티를 수정하여도 그 변경사항이 problem3의 매개변수에게 반영되지 않습니다. 4번 문제: arguments.callee는 Unmapped arguments 객체에서 접근할 수 없습니다.12345function problem4(a, b, c = 10) &#123; return arguments.callee;&#125;problem4(1, 2) // 반환값을 맞추어 보세요! 정답: 반환값 없음(TypeError) 여기서도 문제 3과 같은 이유로 Unmapped arguments 객체가 생성됩니다. 아시다시피 Unmapped arguments 객체의 callee 프로퍼티는get 이든 set 이든 TypeError를 일으키는 접근자로만 이루어진 접근자 프로퍼티입니다. 5번 문제: arguments 객체는 배열이 아닙니다.123456function problem5() &#123; arguments[2] = 3; return Array.prototype.slice.call(arguments);&#125;problem5(1, 2); // 반환값을 맞추어 보세요! 정답: [1, 2] 아까 우리가 살펴 본 [[Set]] internal method에는 프로퍼티의 수가 변경되었다고 해서 arguments 객체의 length 프로퍼티를 수정하는 로직을 가지고 있지 않았습니다.하지만 Array.prototype.slice 메서드는 주어진 객체의 length를 가지고 주어진 객체를 탐색하고 복사하지요.그렇기에 Array.prototype.slice는 length(2)만 보고 arguments 객체의 &#39;2&#39;을 키로 갖는 프로퍼티를 복사하지 않게 됩니다. End후우, 드디어 이 길고 긴 글이 끝을 맺게 되었네요.부족한 필력에도 뒤로가기를 누르시지 않고 여기까지 읽어주셔서 감사합니다 :)다음에는 더 좋은 자료로 돌아오도록 하겠습니다. 모두 즐거운 금요일 되세요!","categories":[{"name":"JavaScript","slug":"Documents-About-JavaScript","permalink":"https://environmentset.github.io/categories/Documents-About-JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://environmentset.github.io/tags/JavaScript/"},{"name":"proposal","slug":"proposal","permalink":"https://environmentset.github.io/tags/proposal/"}]},{"title":"objectel: Event-Driven Reactive Programming Library","slug":"objectel-Event-Driven-Reactive-Programming-Library","date":"2019-01-16T16:32:14.000Z","updated":"2019-01-18T14:58:46.000Z","comments":true,"path":"2019/01/17/objectel-Event-Driven-Reactive-Programming-Library/","link":"","permalink":"https://environmentset.github.io/2019/01/17/objectel-Event-Driven-Reactive-Programming-Library/","excerpt":"","text":"저는 리액트의 열렬한 팬입니다. 와! virtual dom! 와! component!리액트의 이러한 개념들은 수많은 개발자들을 매료시켰는데요, 단순히 ‘react‘ 라는 키워드를 검색하면 나오는 결과가 이 사실을 보란듯이 증명해줍니다. 확실히, 리액트의 등장으로 ‘거대한‘ 웹 어플리케이션 제작은 기존보다 난이도가 낮아졌습니다.리액트가 채택한, 프로그래밍의 변치 않는 본질적인 요소, ‘분해와 합성‘이 정확하게 먹혀들어간거죠. 지금도 우리는 리액트를 통해 충분히 행복하게 개발하고 있다고 생각합니다.하지만.. 더 나아질 수는 없을까요? Way back Event-Driven programming리액트는 ‘분해와 합성‘을 주 패턴으로 채택한 프레임워크로서High Order Component, Functional Component 등을 통해 계층적인 웹 어플리케이션을 구성하는 디자인을 택했습니다.이 디자인은 모던 웹 어플리케이션을 개발할 때 아주 효과적인데요, 이런 리액트의 디자인에도 몇 아쉬운 점이 있습니다. 1: 컴포넌트끼리의 상호작용이 힘듭니다. 기본적으로 컴포넌트간의 상호작용은 인접한 컴포넌트끼리 props 를 통해 콜백이나 데이터 등을 전달하는 방식으로 이루어지기 때문에,서로 상호작용을 하는 두 컴포넌트가 있을 때, 이 둘의 거리가 멀어질 수록더 많은 컴포넌트들이 두 컴포넌트의 상호작용을 위해 희생(props 항목 증가)을 하게 됩니다. 물론 이 문제는 해결책이 등장하긴 했습니다. 바로 Context API 지요.하지만 저는 아직도 불만이 있습니다. 1.1: 상호작용을 위한 값을 제공할 Provider 아래에 상호작용할 모든 컴포넌트들이 존재해야 한다. 이렇게 되면 결국 다른 컴포넌트 하나가 다른 컴포넌트들의 상호작용을 위한 업무를 떠안거나 이 업무만을 위한 컴포넌트를 하나 만들어야 합니다. 그리고 두 컴포넌트 간의 너비가 넓으면 넓을 수록 Provider(혹은 그에 준하는 역할을 가진 컴포넌트)의 높이는 점점 낮아지게 됩니다.또한 Provider의 범위 밖에 있는 컴포넌트와 상호작용을 하려면 Provider의 높이를 낮추기 위해, 혹은그 컴포넌트를 Provider의 범위 안에 들어오게 하기 위해 기존의 코드를 뜯어고치는 상황이 발생하게 됩니다. 1.2: 여러 Context를 동시에 참조하기 어렵습니다. 클래스 컴포넌트의 경우 Context를 참조하는 특별한 방법으로 Class.contextType 과 this.context가 있지만,아쉽게도 Class.contextType으로 지정한 하나의 Context만 참조할 수 있습니다. 그럼 남은 방법은 Consumer 뿐인데요, 얘도 자신과 함께 생성된 Provider가 제공하는 Context만 참조할 수 있습니다.그렇기에 일반적으로 여러 Context를 동시에 참조하려면 아래와 같이 해야 하는데요, harmony1234567891011&lt;MyContext1.Consumer&gt; &#123; x =&gt; ( &lt;MyContext2.Consumer&gt; &#123; y =&gt; ( &lt;Result&gt; &#123; x + y &#125; &lt;/Result&gt; )&#125; &lt;/MyContext2.Consumer&gt; )&#125;&lt;/MyContext1.Consumer&gt; 이런 방식은 상당히 불편합니다. 다행스럽게도 HOC를 통해 컨텍스트를 전부 하드코딩하는 최악의 상황은 면할 수 있지만그래도 코드가 더러워지는 건 사실입니다. 우리가 jsx를 통해 알고 싶은 건 ‘웹 어플리케이션이 어떻게 보일 지‘, ‘어떤 주요 로직이 있는지‘ 이지어떤 컨텍스트들이 내려가는 지, 제공되는 지는 아니잖아요. 2: 컴포넌트 바깥의 사정을 고려해야 합니다. 매 컴포넌트를 만들 때 마다 누가 어떻게 이 컴포넌트를 다룰 지, 어떻게 결과를 내보내 주어야 하는지 등에 대해 고민해야 합니다.이런 부수적인 고민들은 가장 중요한 ‘컴포넌트의 메인 로직‘(어떻게 데이터가 다뤄지는 가, 무엇이 랜더링되는 가 등..)을 고민하지 못하게 프로그래머를 방해합니다. 예를 하나 들어보지요, 우리는 지금 입력 폼의 입력 컴포넌트를 작성하고 있습니다.const InputField = () =&gt; {} 먼저 컴포넌트의 뼈대를 작성하자 마자 수많은 질문이 쏟아져 나옵니다.“입력 검증은 어떻게 하지? 정규식? 검증 함수?”, “controlled component로 만들까?”, “그럼 값이 변경되었음은 어떻게 알리지?”, “오류가 발생하였음은 어떻게 알리지?”,“드롭다운 버튼이라면 입력 리스트는 어떻게 받고?” 이 질문들 중, ‘컴포넌트의 메인 로직‘작성 과 직결된 질문은 몇 가지일까요?정답은 2개 입니다. 입력 검증과, 컴포넌트의 형식을 제외한 나머지 질문들은 컴포넌트가 입력을 어떻게 받을 지, 어떻게 내보낼 지에 대한 질문일 뿐입니다.그리고 이런 질문들은 각 컴포넌트들이 ‘캡슐화가 덜 되었음‘을 여실히 알려주지요. 하지만 아시다시피 리액트는 여기서 더 이상의 캡슐화를 할 수 없습니다. 3: 별로 리액티브 하지 않습니다. 모든 컴포넌트는 기본적으로 Props, State의 변화에만 반응합니다.어플리케이션(혹은 다른 컴포넌트의 상태)의 변화에 반응하려면 콜백과 같은 수단을 사용하여야만 하지요.하지만 앞서 언급했듯이 props는 기본적으로 근접한 ‘자식’ 컴포넌트와만 교환할 수 있기 때문에 멀리 떨어진 컴포넌트에게 콜백을 전달하기란..쉽지 않은 일인 건 확실합니다. 그리고 전 제 컴포넌트들이 자신과 관련없는 ‘상태 알리미 콜백‘으로 점칠되는 게 그닥 마음에 들지 않습니다. 좋아요, 여기까지는 제 불만 사항들입니다.그럼.. 이 불만 사항들을 어떻게 해결할 수 있을까요? 몇 달 전, 저는 굉장히 고전적이면서도 효과적인 방법을 찾아냈습니다.저 처럼 문제에만 집중하고 싶어하는 사람들을 위한 방법이였죠. 동화책에서나 나올 법한 유니콘이 아닙니다.Event-Driven Reactive Programming 입니다. Don’t try to control everything, just believe them아주 어렸을 때 읽었던 고사성어 책에서 이런 이야기를 소개했었습니다. 먼 옛날, 한 도시에 새로이 부임한 관리가 있었습니다. 그 관리는 도시를 더 좋게 만들고자제 딴에는 노력을 기울여 도시와 관련된 일이라면 하나부터 열까지 직접 지휘했습니다. 하지만 이런 관리의 노력과는 달리, 백성들을 불만을 토로하고 있었습니다. 도대체 어떻게 된 일일까요? 자신이 무엇을 잘못했는지 알지 못했던 관리는 자신이 부임되기 전에 도시를 맡았던, 백성들이 무한한 존경심을 보냈던은퇴한 관리를 찾아가서 물었습니다. “저는 백성들을 아끼기에 손수 나서서 모든 걸 해결해주었는데 왜 백성들을 제게 불만을 토로하는걸까요? 저는 도통 모르겠습니다.”그러자 관리가 답했습니다. “자네는 백성들을 아끼지만, 백성들을 믿지 못해서 문제라네. 백성들에게 일을 믿고 맡기게나, 자네가 믿음을 표현한다면 백성들도 그 믿음에 보답하고자 제 일에 최선을 다할걸세” 믿음을 가져라, 신뢰해라, 비단 과거에만 통하는 이야기는 아닙니다.넷플릭스, 에어비엔비 등 빠른 시간에 지대한 성장을 이루어 낸 스타트업 회사들의 업무 처리 방식이기도 합니다.계획서 대신 업무를 맡은 직원의 아이디어로, 명령 대신 “이 사람은 이 분야의 전문가“라는 믿음으로 기다립니다. 프로그래밍은 현실의 문제를 푸는 일입니다. ‘다른 어떤 미지의 문제‘가 아니라요.이런 프로그래밍에서, 현실에서 성공한 문제 해결 방식을 도입하는 건 분명 효과적이지 않을 수가 없습니다. 그렇기에 저는 새로운 라이브러리를 만들기 위해 현실에서 성공한 두 가지 문제 해결 방식을 선택했습니다.바로 ‘분업‘과 ‘믿을만한 전문가‘ 입니다. 이 중에서 ‘분업‘은 분할 정복이라는 이름으로 이미 프로그래밍 계에 소개되었습니다.위에서 설명한 리액트도 분할 정복을 잘 적용한 예시 중 하나구요.하지만 ‘믿을만한 전문가‘는요..? 사실 따지고 보면 프로그램을 함수로, 객체로, 아니 그 무엇으로 나누어도 우리는 ‘믿을만한 전문가‘ 방식을 사용하고 있다고 주장할 수 있습니다.‘자기 코드를 믿지 않는 프로그래머는 세상에 없거든요!‘, 우리는 코드를 작성할 때 “이 코드가 돌아가지 않으면 어쩌지?”보다“이 코드가 돌아가면 이 코드도 돌아가고 여차저차해서 프로그램이 잘 돌아갈거야!” 라고 생각하지요. 그래서 오류를 발견하면 놀라는 거구요.기대가 없으면 실망도 없잖아요!. 이쯤 되면 이런 생각을 하시는 분들도 계실겁니다. 나는 내 프로그램도 작게 쪼갰고, 내 코드도 믿는 데 왜 프로그래밍이 더 힘들어졌어.. 다원적인 고민이지요, 하지만 대부분의 경우 이 문제는 단 하나의 도구를 들여오면 해결됩니다.바로 ‘개체 간의 상호작용을 위한 도구‘ 입니다. 문제를 쪼개어 여러 전문가에게 나누어 풀게 하고 싶으면 당연히 그 전문가들과, 그 전문가들끼리 상호작용할 수 있게 해 주는 도구가 있어야 합니다.이 도구를 만드는 방식은 정말 많은데요. 저는 그 중에서도 ‘이벤트 스트림‘을 선택했습니다. 즉, 저는 리액트의 문제를 해결하기 위해 ‘이벤트 스트림을 통해 각 전문가 코드가 소통을 할 수 있게 만들었다‘ 라는 이야기입니다. objectel: Event-Driven Reactive Programming Library좋아요, ‘문제의 분해와 합성’, ‘이벤트 스트림을 통한 상호작용’, ‘리액티브 프로그래밍’ 이게 지금까지 다루어 온 주제입니다.이제 본격적으로 위의 논의 사항을 바탕으로 만들어진 라이브러리, objectel을 소개하도록 하겠습니다. objctel은 컴포넌트 단위로 문제를 쪼갠 후, 이벤트 스트림을 통해 다시 병합하여 문제를 해결할 수 있게 해주는 라이브러리입니다. 그럼, 지금부터 아래의 간단한 예제 코드를 살펴보면서 objectel이 어떻게 제가 위에서 제시한 문제점들을 해결하였는지 살펴보도록 하겠습니다. P.S objectel의 API에 익숙하지 않으신 분들을 위해 소소하게 주석을 달아두었습니다.다만 생략한 몇몇 부분이 있기에 objectel을 공부하시려는 분들은 저장소의 API문서를 읽으시는 걸 권장드립니다. harmony1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import * as Ol from 'objectel';import merge from 'callbag-merge';/*** Ol.component(propsToModel, modelToResult, eventHandlerMap)* propsToModel: 엘리먼트가 활성화 될 때 호출됩니다. * 함수의 반환값은 엘리먼트의 초기 상태를 결정하기 위해 사용됩니다.* modelToResult: 엘리먼트의 model이 수정되었을 때 호출됩니다.* 함수의 반환값은 즉시 출력 스트림을 통해 전파됩니다.* eventHandlerMap: event type: handler 형태의 객체입니다.* 입력 스트림으로 지정된 타입의 이벤트가 들어왔을 때 event.payload, props, prevModel 형태로 호출됩니다. */const Counter = Ol.component( props =&gt; props.startValue, count =&gt; Ol.createEvent('log', &#123; from: Counter, value: count&#125;), &#123; 'increase': (amount, _, prevCount) =&gt; prevCount + amount, &#125;,);const Logger = Ol.component( () =&gt; 'logger has been initialized', console.log, &#123; 'log': (&#123; from, value &#125;) =&gt; `Log: $&#123;value&#125; / from: $&#123;from&#125;`, &#125;);/*** Functional Component* props =&gt; event$ =&gt; output stream 형태의 함수입니다.*/const App = (&#123; children &#125;) =&gt; &#123; if (!Array.isArray(children)) children = [children]; return event$ =&gt; &#123; const &#123; Emit$, Listen$ &#125; = Ol.createEventBus(); Emit$(event$); return merge(children.map(element =&gt; element(Listen$))); &#125;&#125;;/*** Ol.createEventBus(...initEvents)* 이벤트 버스를 생성하고 initEvent 들로 초기화합니다.* listener sink인 Emit$과 listenable source인 Listen$를 반환합니다.* Emit$은 주어진 source가 emit하는 값을 이벤트 버스의 리스너들에게 전달해줍니다.* Listen$은 자신을 listen하는 sink에게 이벤트 버스에 Emit 된 값을 전달해줍니다.*/const globalEventBus = Ol.createEventBus();/*** Ol.createElement(component, props, children)* 주어진 component와 props를 통해 element를 생성합니다.*/const app = ( &lt;App&gt; &lt;Counter startValue=&#123;0&#125; /&gt; &lt;Logger /&gt; &lt;/App&gt;);globalEventBus.Emit$(app(globalEventBus.Listen$)); objectel은 event(혹은 여러분이 만든 어떤 것)을 스트림을 통해 모든 엘리먼트가 공유하게 함으로서서로 상호작용을 할 컴포넌트끼리 서로 알지 못하여도 상호작용을 할 수 있게 만들었습니다. Counter 컴포넌트1234567const Counter = Ol.component( props =&gt; props.startValue, count =&gt; Ol.createEvent('log', &#123; from: Counter, value: count&#125;), &#123; 'increase': (amount, _, prevCount) =&gt; prevCount + amount, &#125;,); Logger 컴포넌트1234567const Logger = Ol.component( () =&gt; 'logger has been initialized', console.log, &#123; 'log': (&#123; from, value &#125;) =&gt; `Log: $&#123;value&#125; / from: $&#123;from&#125;`, &#125;); 그 예로, 이 두 컴포넌트는 서로를 알지 못합니다. 하지만 App 컴포넌트를 통해 Counter의 출력 스트림과Logger의 입력 스트림이 연결되어 상호작용을 하는 방법에 대한 고민 없이, 서로 이벤트를 통해 상호작용 할 수 있는 상태가 되었습니다. 또한, prop, model의 변화가 아닌 그저 ‘이벤트의 수신’을 기반으로 모든 것이 작동하기 때문에 더욱 더 수준 높은리액티브 프로그래밍이 가능합니다. 어떠신가요? 한번 써 보고 싶으시지 않으신가요?저는 여기서 objectel 소개를 마치고 다음 글인 ‘objectel로 간단한 카운터 웹 어플리케이션 만들기’로 돌아오겠습니다. More reading objectel project repository: objectel 프로젝트의 저장소입니다. 아래 저장소들의 모노레포입니다.objectel repository: objectel의 저장소입니다.objectel with snabbdom: Vue가 포크하여 사용하고 있는 Virtual DOM 구현체인 snabbdom을 objectel에서 쉽게 사용할 수 있게 컴포넌트 형태로 제공해주는 snabbel 라이브러리 사용 예시가 있는 저장소입니다.snabbel: snabbel의 저장소입니다.objectel-events: objectel의 이벤트를 다루는 유틸리티 함수를 제공하는 라이브러리입니다. objectel 프로젝트에 대한 컨트리뷰트는 언제나 환영입니다 :)","categories":[{"name":"JavaScript","slug":"Documents-About-JavaScript","permalink":"https://environmentset.github.io/categories/Documents-About-JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://environmentset.github.io/tags/JavaScript/"},{"name":"objectel","slug":"objectel","permalink":"https://environmentset.github.io/tags/objectel/"},{"name":"Event Driven programming","slug":"Event-Driven-programming","permalink":"https://environmentset.github.io/tags/Event-Driven-programming/"},{"name":"Reactive programming","slug":"Reactive-programming","permalink":"https://environmentset.github.io/tags/Reactive-programming/"},{"name":"Functional programming","slug":"Functional-programming","permalink":"https://environmentset.github.io/tags/Functional-programming/"}]},{"title":"Stop using CSS with React","slug":"Stop-using-CSS-with-React","date":"2019-01-05T15:20:04.000Z","updated":"2019-01-18T14:58:46.000Z","comments":true,"path":"2019/01/06/Stop-using-CSS-with-React/","link":"","permalink":"https://environmentset.github.io/2019/01/06/Stop-using-CSS-with-React/","excerpt":"","text":"TL;DRReact(혹은 자체적인 Component를 가지고 있는 프레임워크)를 사용할 때, CSS selector가 제 역할을 하지 못하게 되어React의 Component에 styling과 직접적으로 관련된 추가적인 로직이 포함되게 됩니다. 이는 CSS(SCSS)와 Component 사이의 어중간한 분리를 불러일으킵니다(Control coupling). 이 문제에 대해, styled-component와 emotion같은 CSS-IN-JS 라이브러리들은 Component와 그 Component의 Style을 1대 1로,아주 강하게 묶어내서 하나의 모듈로 병합시키는 방식을 선택했습니다.이 방식은 지금까지 등장한 방식 중 단연 효과적이였습니다. 1대 1로 강하게 묶어버리면서 두 개의 분리된 모듈을 하나의 모듈로 병합시켰고,그로 인해 코드가 낮은 결합도를 취할 수 있게 하였습니다. 이런 이유로 저는 여러분들께 CSS(SCSS)를 떠나 CSS-IN-JS를 쓰시는 것을 추천드립니다. CSS’S Styling Cascading Style Sheets (CSS) is a simple mechanism for adding style (e.g., fonts, colors, spacing) to Web documents. - W3C Cascading Style Sheets (CSS) 는 웹 문서에 스타일을 제공하기 위한 간단한 메커니즘 입니다. - W3C 아시다시피, CSS는 웹 문서에 스타일을 적용하기 위한 언어입니다.웹 문서에 스타일을 적용하기 때문에, 대상은 자연스럽게 HTML Element가 됩니다. 하지만, HTML에는 정말 많은 종류의 HTML Element가 정말 많은 위치에 자리하고 있습니다(i.e: &lt;head&gt; 안에, &lt;body&gt;와 &lt;div&gt; 안에, 등등…).CSS는 어떻게 ‘어떤 종류의 Element’, ‘어디에 있는 Element’를 찾아 스타일링할까요? CSS는 CSS selector를 통해 스타일링의 대상을 지정하는 방식을 사용합니다.1234567891011body &#123; background-color: yellow;&#125;input[type='file'] &#123; background-color: red;&#125;.draggableImage &#123; cursor: grab;&#125; CSS selector를 사용하면 스타일링할 HTML Element의 거의 모든 정보를 서술하여 구체적인 대상을 설정할 수 있습니다.(심지어 그 위치까지 서술할 수 있습니다!!!) 이렇게 강력한 무기를 가졌기 때문에 CSS는 지금까지도 대체품을 만드려는 거대한 그룹이 없습니다. 이를 확장한 언어를 만드는 그룹은 있어도요(SCSS). 하지만 React와 같이 Virtual DOM과 자체적인 Element를 가진 프레임워크(혹은 라이브러리, 뭐시 중허나요.)가 등장하자 CSS의 강력한 무기인 selector의 위기가 찾아왔습니다. CSS Selector is not a sliver bullet!앞서 이야기했듯이, CSS가 스타일링 할 대상은 HTML Element 입니다. React Element가 아니라요.그렇기 때문에 CSS selector는 HTML Element를 지정하기 위한 정보를 서술할 수는 있어도 React Element를 지정하기 위한 정보는 서술할 수 없습니다. 이 점을 알고 있는 React 개발자들은 React Element(와 기타 데이터들)를 DOM Node로 변환시키기 위한 라이브러리인 react-dom 에서HTML Element에 대응하는 React Element를 생성할 때, className 이라는 property를 받아, 차후 HTML Element 로 변환할 때 class attribute로 넣어주는 기능을 포함해서,대응하는 React Element의 property를 통해 HTML Element의 attribute를 설정하는 기능을 만들었습니다. 이 기능을 통해 React를 사용하는 개발자들은 CSS selector를 이용할 수 있게 되었습니다.harmony1234567import React from 'react';const MyButton = () =&gt; ( &lt;button className='customButton blue'&gt; click me! &lt;/button&gt; ); 1234567.customButton &#123; border-radius: 50%;&#125;.blue &#123; background-color: blue;&#125; 음… Component의 Style을 바로 볼 수 없는 게 안타깝긴 하지만 이건 개인 취향이니 넘어가도록 하지요.이렇게 간단한 컴포넌트를 만드는 경우에는 className(class attribute)를 통해 styling을 받는 것도 만족스러워 보입니다. 하지만, Component의 property 혹은 상태에 따라 style을 변경해야 하는 경우에는 이야기가 달라집니다.harmony1234567891011import React from 'react';const MyButton = (&#123; clicked, onClick &#125;) =&gt; &#123; const color = clicked ? 'red' : 'blue'; return ( &lt;button className=&#123;`customButton $&#123;color&#125;`&#125; onClick=&#123;onClick&#125;&gt; click me! &lt;/button&gt; );&#125;; 1234567891011.customButton &#123; border-radius: 50%;&#125;.red &#123; background-color: red;&#125;.blue &#123; background-color: blue;&#125; 문제점이 보이시나요? 다시 처음으로 돌아가 생각해보죠. CSS란? -&gt; 웹 문서에 스타일을 적용하기 위한 언어 CSS의 역할은? -&gt; HTML Element 스타일링 스타일링이란? -&gt; 특정 디자인이 필요한 대상에게 디자인을 입혀주는 것 대상에게 입혀주는 것이란? -&gt; 대상을 찾아 능동적으로 디자인을 입혀주는 것 (만약 대상이 직접 찾아오는 거였다면 CSS selector는 필요하지 않은 요소이다.) 위 예제에서 CSS는 CSS selector를 통해 능동적으로 HTML Element를 스타일링하는가? -&gt; 9번째 줄에서 class name을 연산하고, 12번째 줄에서 연산한 class name을 React Component가 적용하기 때문에 아니다. 위 예제에서 CSS는 자신이 마땅히 해야 하는 일을 다 하였는가? -&gt; 아니다, HTML Element의 색을 스스로 결정하지 못했기 때문이다. 이제 문제점이 보이시나요? 위 코드의 문제는 바로, CSS가 해야 하는 스타일링 이라는 작업의 일부를 React Component가 하고 있는 것입니다!CSS와 React Component가 서로 완벽하게 분리된 것도, 완벽하게 결합된 것도 아닙니다. 어중간하게 결합된 것 입니다! 즉, 만약 우리가 웹 페이지의 형태를 바꾸기 위해 CSS 코드를 수정하면 React Component를 수정해야 할 지도 모릅니다. React Component와 CSS가 스타일링 이라는 작업을 같이 담당하고 있기 때문이죠.반대로 React Component를 수정하면 CSS 코드를 수정해야 할 지 모릅니다. 이렇게, 우리의 든든한 아군이자, CSS의 강력한 무기였던 CSS selector가 만병통치약이 아님이 밝혀졌습니다. Use CSS-IN-JS instead of CSS selector자, React Element 스타일링이라는 카이주를 잡기 위한, 새로운 예거를 여러분들께 소개해드리겠습니다. 바로.. CSS-IN-JS! “CSS-in-JS” refers to a pattern where CSS is composed using JavaScript instead of defined in external files. - React Blog “CSS-in-JS”는 CSS를 추가적인 파일에 정의하지 않고 JavaScript 코드와 결합시켜서 정의하는 패턴을 의미합니다. - React Blog CSS selector가 React Element를 만나면 무능력해지는 문제를 React 진영의 몇몇 사람들은 CSS 코드를 React Component와 묶어버리는 방법을 통해 해결했습니다.아래와 같이요. harmony1234567import React from 'react';import styled from 'styled-components'const MyButton = styled.button` border-radius: 50%; color: $&#123;(&#123; clicked &#125;) =&gt; clicked ? 'red' : 'blue'&#125;`; 이렇게 styled-components를 통해 CSS-IN-JS를 사용함으로서 React Component와 CSS가 하나로 합쳐지면서 두 개의 어중간한 결합성을 가진 개체에서 하나의 독립적인 개체가 되었습니다. 이제 우리는 CSS 와 React Component간의 결합도에 대해 걱정하지 않아도 됩니다. 한 몸이 되었기 때문이죠. 자, 어떠신가요? 이제라도 CSS-IN-JS를 쓰고 싶지 않으신가요? 마지막으로 저는 제가 좋아하는 CSS-IN-JS 라이브러리들을 여러분들께 소개해드리며 이만 글을 마치도록 하겠습니다. styled-components가장 유명한 CSS-IN-JS 라이브러리입니다. tagged template 을 이용해 깔끔하고 세련된 방식으로 component를 styling 하는 방법을 제공합니다. glamorouspaypal의 CSS-IN-JS 라이브러리입니다. 지금은 관리가 중단되어 프로젝트가 정지된 상태입니다. 객체 리터럴을 이용한 styling을 제공합니다.또한 styling 하며 생길 수 있는 몇몇 문제에 대한 해법이 마련되어 있습니다. (제 손에 익은 라이브러리입니다.) emotionglamorous와 styled-components를 계승하는 라이브러입니다. glamorous보다 더 빠르고 더 가벼우며 tagged template과 객체 리터럴을 이용한 styling을 지원합니다.","categories":[{"name":"JavaScript","slug":"Documents-About-JavaScript","permalink":"https://environmentset.github.io/categories/Documents-About-JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://environmentset.github.io/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"https://environmentset.github.io/tags/React/"},{"name":"CSS","slug":"CSS","permalink":"https://environmentset.github.io/tags/CSS/"},{"name":"anti-pattern","slug":"anti-pattern","permalink":"https://environmentset.github.io/tags/anti-pattern/"}]},{"title":"My Old Blog","slug":"My-Old-Blog","date":"2018-09-22T18:35:50.000Z","updated":"2019-02-12T21:30:47.539Z","comments":true,"path":"2018/09/23/My-Old-Blog/","link":"","permalink":"https://environmentset.github.io/2018/09/23/My-Old-Blog/","excerpt":"","text":"개인 블로그를 github pages 로 이전하기 전에 사용하던 블로그 입니다. 네이버 블로그","categories":[],"tags":[{"name":"Notice","slug":"Notice","permalink":"https://environmentset.github.io/tags/Notice/"}]},{"title":"ts, are you sure?","slug":"ts-are-you-sure","date":"2018-07-20T20:04:35.000Z","updated":"2019-01-18T14:58:48.000Z","comments":true,"path":"2018/07/21/ts-are-you-sure/","link":"","permalink":"https://environmentset.github.io/2018/07/21/ts-are-you-sure/","excerpt":"","text":"어제, 페이스북의 그룹에서 흥미로운 질문을 하나 보았었다. 처음에는 오브젝트를 배열의 요소로 알아듣고, 길이가 8, 요소가 8개. 같은 의미입니다. 라고 답변했었는데, 작성자분이 올려주신 사진에는 전혀 예상치 못했던 출력이 나와 있었다. 오, 세상에. 같은 코드에서 다른 출력이라니. 아무리 자바스크립트가 멍청해도 이 정도는 아닐 거라 생각했는데. 잠시동안 당황했지만, 이내 정신을 차리고 먼저 타입스크립트가 어떻게 문제의 코드를 트랜스파일링을 하는 지 부터 tsc 를 통해 확인했다. 1234//JS code[...Array(8)].map(_ =&gt; &#123;name: &apos;&apos;&#125;);//when tsc transplie thisArray(8).slice().map(function(_) &#123; return &#123;name: &apos;&apos;&#125;; )); 의미상, Array(8) 은 new Array(8)과 일치합니다. Vanilla JS와 TS의 차이는 크게 두 가지가 있었다. 바닐라의 경우 화살표 함수를 사용했지만, TS는 익명 함수 표현식으로 변경되었다. 바닐라의 spread operator가 TS에서는 Array.prototype.slice 메서드로 대체되었다. 1번이 내는 가시적인 차이점은 this와 arguments 바인딩 정도인데, 위 코드에서 두 요소를 사용하지 않았으므로 넘겼다.즉, 2번이 문제라는 이야기인데, 구체적으로 무엇이 문제일까? 잠시 생각에 잠겨 있다, empty element 가 뇌리에 불현듯 스쳤다. 만약, Array.prototype.values (= Array.prototype[Symbol.iterator]) 이 존재하지 않는 요소를 복사하려 시도해 undefined를 그 값으로 얻고spread operator 가 받아 결과로 내놓는 배열에 정의한다면? 그렇게 되어서 empty element 가 8개인 배열이 아닌 undefined 가 8개인 배열이 된다면? 이거다! 싶었었던 필자는 바로 명세서를 열어 둘의 알고리즘을 살피기 시작했다. 역시나, 둘의 알고리즘은 상이했다. 대략적으로 필자가 간추려서 차이점을 적어보았다. slice 배열의 length 프로퍼티를 통해 길이를 얻는다. 길이를 기반으로 배열에서 얻을(slice) 길이를 구한다. 구한 길이와 시작 인덱스를 기반으로 루프를 돌며 아래의 알고리즘을 진행한다. 인덱스 i(임의의 변수, 통상적인 for 문의 i 를 생각하셔도 무방합니다.) 라는 이름의 프로퍼티가 배열에 없으면 넘어가고(continue), 있으면 그 값을 얻은 후 새로운 배열에 i 라는 이름과 함께 프로퍼티를 정의한다. 새로운 배열을 반환한다. spread operator 배열의 length 프로퍼티를 통해 길이를 얻는다. 얻은 길이가 인덱스(임의의 변수, 통상적인 for 문의 i 를 생각하셔도 무방합니다.) 와 같아질 때 까지 아래의 알고리즘을 반복한다. 배열에서 i라는 이름의 프로퍼티를 가져옵니다. (이때, 존재하지 않으면 undefined를 그 값으로 얻게 됩니다.) 가져온 프로퍼티의 값을 i라는 이름으로 새로운 배열에 정의한다. 새로운 배열을 반환한다. 마지막으로 요약을 하자면,Array.prototype.slice 는 존재하지 않는 요소를 복사하지 않지만, spread operator는 복사하여 결과 배열에 정의하기에 이후 실제 존재하는 배열의 요소만 순회하는 Array.prototype.map 의 동작의 영향을 준 것.이라고 할 수 있다. 그럼, 이상으로 글을 마치도록 하겠다. 새벽에 갑자기 일어나서 써서 그런지 알고리즘 설명이 꼬여있는 거 같은 건 기분탓인가요..ㅜㅜ존대가 아닌 어투로 글을 처음 써보았는데요, 제 평소 이미지랑 너무 안맞아서 그런지 어색합니다 ㅎㅎ 다음 글 부터는 다시 존대로 돌아가도록 하겠습니다!읽어주셔서 감사합니다:)","categories":[{"name":"JavaScript","slug":"Documents-About-JavaScript","permalink":"https://environmentset.github.io/categories/Documents-About-JavaScript/"},{"name":"TMI","slug":"Documents-About-JavaScript/Too-Much-Infomation","permalink":"https://environmentset.github.io/categories/Documents-About-JavaScript/Too-Much-Infomation/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://environmentset.github.io/tags/JavaScript/"},{"name":"TMI","slug":"TMI","permalink":"https://environmentset.github.io/tags/TMI/"}]},{"title":"Who am I?","slug":"introduce","date":"2018-07-01T10:43:35.000Z","updated":"2019-01-30T23:57:26.850Z","comments":true,"path":"2018/07/01/introduce/","link":"","permalink":"https://environmentset.github.io/2018/07/01/introduce/","excerpt":"","text":"IntroducePrivacy Name : 서재원(Jaewon Seo)Old : 16(2004)GithubGitlabSNS(FACEBOOK) His story2015 게임 MineCraft PE를 통해 프로그래밍을 시작했습니다 ModPE Script를 공부했습니다 2016 게임 Dayz를 Minecraft 버전으로 제작했습니다 2017 10회 코드게이트 참여 - 오픈 CTF 23위 3회 H4C 해킹캠프 - 스탭으로서 참여 &amp; CTF 문제 출제 JavaScript로 만들어진 어셈블리어 방언 실행기 - envssembly 제작envssembly NYPC 본선 참가 SGML의 형태에서 영감을 얻어 만든 프로그래밍 언어 TTeok 2017 설계TTeok JavaScript로 만들어진 TTeok의 인터프리터, DalToki 제작DalToki H4C CTF 문제 출제 ‘What is ‘What is sql injection? Dose it Food?’ 혀엉… 언어 인터프리터 제작혀엉… 언어 명세 뉴시큐 CTF 문제 출제 (CoCa-Cola) 2018 음식 위키 서비스 레씨피 개발ReSeaPe 좀 더 엄격한 자바스크립트 프로그래밍을 도와주는 typedscript.js 개발typedscript.js proposal-decorator 표준 문서 컨트리뷰트proposal-decorator 마이크로소프트웨어 7월호에 기고: 미래의 자바스크립트, ESNext마이크로소프트웨어 393호 마소JS(MASO.js) Angelswing 인턴쉽angelswing 0xD seminal 발표: You can’t handle javascript ecma262 컨트리뷰트ecma262 proposal-class-field, proposal-private-methods 컨트리뷰트proposal-calss-fieldproposal-private-methods FEConf2018 스피커, ‘TC39 스펙에 대한 주관적 참견 시점’feconf2018 2019","categories":[{"name":"Notice","slug":"Notice","permalink":"https://environmentset.github.io/categories/Notice/"}],"tags":[]},{"title":"How break statement breaks break statement","slug":"How-break-statement-break-statement","date":"2018-06-22T10:32:00.000Z","updated":"2019-02-12T08:51:11.355Z","comments":true,"path":"2018/06/22/How-break-statement-break-statement/","link":"","permalink":"https://environmentset.github.io/2018/06/22/How-break-statement-break-statement/","excerpt":"","text":"최근에, 어떤 분의 프로그램을 고쳐드리면서 매우 재미있는 코드를 보았었습니다. 123456something: &#123; ... if(status === false) break something; else ... &#125; 오, 이런. 저도 자주 보지 못한 코드이기에 스타일을 지적하기 전에 실행을 시켜보았었습니다. 세상에, 잘 작동합니다. 진짜 Block 문이 멈추어 버렸어요! 늘 그렇듯이, 까닭이 궁금했던 저는 바로 명세서를 뒤적거리기 시작했습니다.그리고 자바스크립트의 명세서의 13.13.14 Runtime Semantics: LabelledEvaluation 에서 그 이유를 찾을 수 있었습니다. 1234561. Let label be the StringValue of LabelIdentifier.2. Append label as an element of labelSet.3. Let stmtResult be LabelledEvaluation of LabelledItem with argument labelSet.4. If stmtResult.[[Type]] is break and SameValue(stmtResult.[[Target]], label) is true, then a. Set stmtResult to NormalCompletion(stmtResult.[[Value]]).5. Return Completion(stmtResult). 명세서를 읽을 줄 모르시는 분들을 위해, 간략하게 요약해 보자면. Label이 달린 구문을 실행한 후, 그 결과가 자신을 대상으로 하는 break라면 그 break를 제어하여 오류가 발생하지 않게 막는다.(자바스크립트의 명세서에서는 스크립트의 실행 결과가 break, return, continue, throw 라면 구현체에서 오류를 발생시키도록 명시하고 있습니다. 그래서 함수 객체를 실행시키는 [[Call]] 메서드 등을 보면 return을 normal(유일하게 오류를 일으키지 않는 결과)로 바꾸지요. 여기서도 마찬가자입니다.) 할 이야기는 전부 한 거 같으니, 간단한 Q&amp;A를 진행하고 이만 마치도록 하겠습니다. 봐주셔서 감사합니다 :) Q&amp;AQ: if 문에서도 사용 가능하나요?A: 네, 됩니다. Q: 많은 코드의 for 문, switch 문, while 문 등을 보면 대상을 지정하지 않는 break 를 사용하는 경우가 있는데 그 경우는 어디서 처리하나요?A: 13.1.7 Runtime Semantics: LabelledEvaluation 에서 명시하고 있습니다. 간략하게 말씀드리자면 그 경우들은 가장 가까운 Breakable 문(switch, for, while 등)이 처리합니다. Q: 좋은 방식인가요?A: 제 주관적인 생각으로는 안티 패턴이라고 생각합니다. break로 구문의 진행을 저지해야 하는 경우를 생각해보면 전부 함수로 프로세스를 추상화하고 이들을 조합하는 방식으로 해결할 수 있고, 이 방법이 유지 보수 면에서 더 나은 방식이라고 생각합니다. Reference","categories":[{"name":"JavaScript","slug":"Documents-About-JavaScript","permalink":"https://environmentset.github.io/categories/Documents-About-JavaScript/"},{"name":"TMI","slug":"Documents-About-JavaScript/Too-Much-Infomation","permalink":"https://environmentset.github.io/categories/Documents-About-JavaScript/Too-Much-Infomation/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://environmentset.github.io/tags/JavaScript/"},{"name":"TMI","slug":"TMI","permalink":"https://environmentset.github.io/tags/TMI/"}]},{"title":"Two face of identifier","slug":"Two-face-of-identifier","date":"2018-06-11T13:38:00.000Z","updated":"2019-01-18T14:58:46.000Z","comments":true,"path":"2018/06/11/Two-face-of-identifier/","link":"","permalink":"https://environmentset.github.io/2018/06/11/Two-face-of-identifier/","excerpt":"","text":"프로그래밍 언어에서 식별자는 아주 중요합니다.식별자는 값, 타입 따위에 묶임으로서 궁극적으로 프로그래머가 주소가 아닌 이름으로서 변수에 접근할 수 있게 해줍니다.아마 여러분들은 자바스크립트를 시작하실 때 변수와 함께 식별자에 대해 배우셨을겁니다.그만큼 이해하기 쉬운 게 바로 식별자인데요.오늘은 이 식별자에 대해 짧고 깊은 이야기를 나누도록 하겠습니다. 반쪽짜리 식별자여러분들이 아시는 식별자란 무엇인가요? 네, 맞습니다. 예약어 가 아닌 유니코드 문자들의 열이지요.여러분이 통상적으로 알고 계시는 이런 식별자는 명세서에서는 identifier 라는 논 터미널입니다.명세서에서 identifier 의 EBNF 표현식이 기명되는 자리에는 아래와 같이 적혀있습니다. IdentifierName but not ReservedWord 의문스럽게도 identifier 논 터미널 안에 identifierName 이라는 논 터미널이 있습니다! 이쯤되면 눈치채신 분도 계실텐데요.네, 맞습니다 사실 identifier 는 ReservedWord (예약어) 가 아닌 식별자들을 의미하는 것이고, 본체는 identifierName 입니다.보통 통상적으로 보시는 식별자는 identifier 인데요.저는 이것을 식별자의 앞면 이라고 부릅니다.그리고 identifierName 은 식별자의 뒷면 이라고 부르지요. 식별자가 사용되는 많은 케이스에서 identifier 가 사용되는데요.이런 케이스들의 공통되는 특징이 하나 있습니다.바로 특정 구문이나 연산자가 사용될 수 있는 환경 (예: 블록, 함수 몸체, 전역 스코프 등)이라는 점 입니다.특정 구문이나 연산자가 사용될 수 있는 환경에서 이들과 같은 문자들로 이루어진 식별자의 사용을 허용한다면 모호한 구문을 만들어내기에 코드의 파싱이 불가능 해지는데요, 이런 일을 방지하기 위해 예약어가 존재하기 때문에 어찌보면 당연하기도 한 공통점이네요. 식별자의 반대편 얼굴자, 그럼 식별자의 반대편 얼굴을 보도록 하지요.라고 해도 별로 거창한 건 없습니다.위의 보편적인 식별자의 통념에 반대되는 특징 하나 빼고는 다른 게 없거든요.그리고 여러분들은 그 특징이 무엇인지 이미 앞에서 알고 오셨지요.그러니 제게 남은 일은 식별자의 뒷면이 어디서 사용될 수 있는지 알려드리는 거 밖에 없습니다. 여러분들은 식별자의 뒷면이라고 해서 너무 낯설어 하실 필요가 없습니다.사실 여러분들이 알게 모르게 많은 코드에서 쓰이고 있습니다.여러분이 자각하지 못할 뿐이지요.식별자의 뒷면은 예약어가 사용될 수 없는 환경에서 사용됩니다.(예: 객체 리터럴의 프로퍼티 정의시, 클래스의 메서드 정의시 등) 이런 케이스에서는 특정 구문이나 연산자들이 사용될 수 없음이 확실하기에 구문 분석기는 입력받은 식별자가 예약어인지 확인하지 않습니다. 맺는 말내일 수행평가가 4개나 들었는데 전 도대체 뭔 정신으로 글을 쓰고 있는지 모르겠네요 :(여하튼, 제 글을 읽어주셔서 감사합니다 :)","categories":[{"name":"JavaScript","slug":"Documents-About-JavaScript","permalink":"https://environmentset.github.io/categories/Documents-About-JavaScript/"},{"name":"TMI","slug":"Documents-About-JavaScript/Too-Much-Infomation","permalink":"https://environmentset.github.io/categories/Documents-About-JavaScript/Too-Much-Infomation/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://environmentset.github.io/tags/JavaScript/"},{"name":"TMI","slug":"TMI","permalink":"https://environmentset.github.io/tags/TMI/"}]}]}